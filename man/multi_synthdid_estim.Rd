% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_sdid_estim.R
\name{multi_synthdid_estim}
\alias{multi_synthdid_estim}
\title{Computes the synthetic diff-in-diff estimate for an average treatment effect on a treated block with multiple outcomes}
\usage{
multi_synthdid_estim(
  Y,
  N0,
  T0,
  X = NULL,
  noise.level = NULL,
  eta.omega = NULL,
  eta.lambda = NULL,
  zeta.omega = NULL,
  zeta.lambda = NULL,
  omega.intercept = TRUE,
  lambda.intercept = TRUE,
  weights = list(omega = NULL, lambda = NULL, theta = NULL),
  update.omega = is.null(weights$omega),
  update.lambda = is.null(weights$lambda),
  min.decrease = NULL,
  max.iter = 10000,
  sparsify = sparsify_function,
  max.iter.pre.sparsify = 100,
  standardize = (dim(Y)[3] > 1),
  scale_vcov = T,
  out = "all"
)
}
\arguments{
\item{Y}{the observation tensor 3D (unit x time x outcome)}

\item{N0}{the number of control units (N_co in the paper). Rows 1-N0 of Y correspond to the control units.}

\item{T0}{the number of pre-treatment time steps (T_pre in the paper). Columns 1-T0 of Y correspond to pre-treatment time steps.}

\item{X}{an optional 4-D array of time-varying covariates. Shape should be N X T X J x K standing for each j-outcome K covariates.}

\item{noise.level, }{an estimate of the noise standard deviation sigma. Defaults to the scaled standard deviation of first differences of Y. Scaling is based on Reguly et al (2024)}

\item{eta.omega}{determines the tuning parameter zeta.omega = eta.omega * noise.level. Defaults to the value (N_tr T_post)^(1/4).}

\item{eta.lambda}{analogous for lambda.  Defaults to an 'infinitesimal' value 1e-6.}

\item{zeta.omega}{if passed, overrides the default zeta.omega = eta.omega * noise.level. Deprecated.}

\item{zeta.lambda}{analogous for lambda.}

\item{omega.intercept}{Binary. Use an intercept when estimating omega.}

\item{lambda.intercept}{Binary. Use an intercept when estimating lambda.}

\item{weights}{a list with fields lambda, omega and theta. If non-null weights$lambda is passed,
we use them instead of estimating lambda weights. Same for weights$omega.
Default for theta that weights different outcomes during the optimization is equal weights.}

\item{update.omega}{If true, solve for omega using the passed value of weights$omega only as an initialization.
If false, use it exactly as passed. Defaults to false if a non-null value of weights$omega is passed.}

\item{update.lambda}{Analogous.}

\item{min.decrease}{Tunes a stopping criterion for our weight estimator. Stop after an iteration results in a decrease
in penalized MSE smaller than min.decrease^2.}

\item{max.iter}{A fallback stopping criterion for our weight estimator. Stop after this number of iterations.}

\item{sparsify}{A function mapping a numeric vector to a (presumably sparser) numeric vector of the same shape, which must sum to one.
If not null, we try to estimate sparse weights via a second round of Frank-Wolfe optimization
initialized at sparsify( the solution to the first round ).}

\item{max.iter.pre.sparsify}{Analogous to max.iter, but for the pre-sparsification first-round of optimization.
Not used if sparsify=NULL.}

\item{standardize}{TRUE or FALSE. Default is TRUE if J > 1, otherwise FALSE.
If true outcomes are standardized (mean zero unit variance) during the estimation}

\item{scale_vcov}{TRUE or FALSE. If TRUE: scale during the optimization with specific variance-covariance matrix.}

\item{out}{Default = 'all'. Options are:
- 'all': provides all possible estimates
- 'tau_curve': only the treatment effects for each outcome after the event (gaps -- JxT1)
- 'tau': only the point estimates after the event (point estimates Jx1)
- 'tau_all': all the curves: synthetic, treated and treatment curves before and after the events (Jx(T0+T1))}
}
\value{
Specified in 'out'. If all, tau, the output is supplemented with 'weights' and 'setup' attached as attributes.
        'weights' contains the estimated weights lambda and omega and corresponding intercepts,
        as well as regression coefficients beta if X is passed.
        'setup' is a list describing the problem passed in: Y, N0, T0, X.
}
\description{
Method is an extension of 'Synthetic Difference in Differences' by Arkhangelsky et al, Algorithm 1.
}
