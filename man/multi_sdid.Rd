% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_sdid.R
\name{multi_sdid}
\alias{multi_sdid}
\title{Convert classical R regression input to multi synthetic diff-in-diff estimator}
\usage{
multi_sdid(
  formula_yx,
  treatment,
  unit,
  time,
  data,
  SE = T,
  se_type = "placebo",
  se_replication = 200,
  noise.level = NULL,
  eta.omega = NULL,
  eta.lambda = NULL,
  zeta.omega = NULL,
  zeta.lambda = NULL,
  omega.intercept = TRUE,
  lambda.intercept = TRUE,
  weights = list(omega = NULL, lambda = NULL, theta = NULL),
  update.omega = is.null(weights$omega),
  update.lambda = is.null(weights$lambda),
  min.decrease = NULL,
  max.iter = 10000,
  sparsify = sparsify_function,
  max.iter.pre.sparsify = 100,
  standardize = NULL,
  scale_vcov = T
)
}
\arguments{
\item{formula_yx}{classical formula used in R
- multiple outcomes: y1 + y2 + y3 ~ 1
- classical synthetit diff-in-diff: y1 ~ 1
- multiple outcomes with SAME covariates: y1 + y2 + y3 ~ a + b + c
- multiple outcomes with DIFFERENT covariates: cbind(y1,y2,y3)~cbind(a+b,a+c,a+b+c)}

\item{treatment}{character value for the treatment (logical) variable}

\item{unit}{character value for the unit identifier variable}

\item{time}{character value for the time identifier variable}

\item{data}{data.frame or tibble object}

\item{SE}{TRUE/FALSE if compute standard errors or not}

\item{se_type}{type of standard errors
- 'placebo' standard errors (Default)
- 'bootstrap' standard errors}

\item{se_replication}{positive integer for
the number of replication for SE calculation (default = 200).}

\item{noise.level, }{an estimate of the noise standard deviation sigma. Defaults to the scaled standard deviation of first differences of Y. Scaling is based on Reguly et al (2024)}

\item{eta.omega}{determines the tuning parameter zeta.omega = eta.omega * noise.level. Defaults to the value (N_tr T_post)^(1/4).}

\item{eta.lambda}{analogous for lambda.  Defaults to an 'infinitesimal' value 1e-6.}

\item{zeta.omega}{if passed, overrides the default zeta.omega = eta.omega * noise.level. Deprecated.}

\item{zeta.lambda}{analogous for lambda.}

\item{omega.intercept}{Binary. Use an intercept when estimating omega.}

\item{lambda.intercept}{Binary. Use an intercept when estimating lambda.}

\item{weights}{a list with fields lambda, omega and theta. If non-null weights$lambda is passed,
we use them instead of estimating lambda weights. Same for weights$omega.
Default for theta that weights different outcomes during the optimization is equal weights.}

\item{update.omega}{If true, solve for omega using the passed value of weights$omega only as an initialization.
If false, use it exactly as passed. Defaults to false if a non-null value of weights$omega is passed.}

\item{update.lambda}{Analogous.}

\item{min.decrease}{Tunes a stopping criterion for our weight estimator. Stop after an iteration results in a decrease
in penalized MSE smaller than min.decrease^2.}

\item{max.iter}{A fallback stopping criterion for our weight estimator. Stop after this number of iterations.}

\item{sparsify}{A function mapping a numeric vector to a (presumably sparser) numeric vector of the same shape, which must sum to one.
If not null, we try to estimate sparse weights via a second round of Frank-Wolfe optimization
initialized at sparsify( the solution to the first round ).}

\item{max.iter.pre.sparsify}{Analogous to max.iter, but for the pre-sparsification first-round of optimization.
Not used if sparsify=NULL.}

\item{standardize}{TRUE or FALSE. Default is TRUE if J > 1, otherwise FALSE.
If true outcomes are standardized (mean zero unit variance) during the estimation}

\item{scale_vcov}{TRUE or FALSE. If TRUE: scale during the optimization with specific variance-covariance matrix.}
}
\description{
Convert classical R regression input to multi synthetic diff-in-diff estimator
}
